#! /usr/bin/ruby

require 'getoptlong'
require 'set'
require 'digest/sha1'

IDENTIFICATION = 'chktor 0.1'
USAGE = <<"EOF"
chktor -- check whether a BitTorrent file matches a file or directory

usage: chktor [-q] [-xDIR] filename.torrent [checkee]

 -q, --quiet        check quietly
 -x, --extract=DIR  extract valid pieces into the given directory as
                    separate files (named by piece number)

 --help             show this usage
 --version          show version data

EOF

#### Bdecoding

# Parse a bencoded string and return the object represented by it.
def bdecode source
    object, end_offset = bdecode_part source, 0
    raise 'bdecode error' unless end_offset == source.length
    return object
end

# Given a bencoded string and offset in it, parse the object starting at that
# offset.  Return the parsed object and offset in the source string immediately
# past the object's end.
def bdecode_part source, offset
    case source[offset]

    when ?0 .. ?9 then # string
        length = 0
        while (?0 .. ?9).include? source[offset] do
            length = length * 10 + source[offset] - ?0
            offset += 1
        end
        raise 'bdecode error' unless source[offset] == ?:
        offset += 1
        content = source[offset ... offset + length]
        raise 'bdecode error' unless content.length == length
        return content, offset + length

    when ?d then # dictionary
        dictionary = {}
        last_key = nil # we use this to check strictly ascending key order
        offset += 1
        until source[offset] == ?e do
            key, offset = bdecode_part source, offset
            raise 'bdecode error' unless key.is_a? String
            raise 'bdecode error' if last_key and !(key > last_key)
            value, offset = bdecode_part source, offset
            dictionary[key] = value
            last_key = key
        end
        offset += 1
        return dictionary, offset

    when ?l then # list
        list = []
        offset += 1
        until source[offset] == ?e do
            item, offset = bdecode_part source, offset
            list.push item
        end
        offset += 1
        return list, offset

    when ?i then # integer
        offset += 1
        end_offset = source.index(?e, offset)
        raise 'bdecode error' if end_offset.nil?
        integer_face = source[offset ... end_offset]
        # Going by the foundational principle that there's only one way to
        # properly bencode an object, it's obvious that plus signs and extra
        # lead zeroes are verboten in bencoded integers.
        raise 'bdecode error' unless integer_face =~ /\A(0|-?[1-9]\d*)\Z/
        value = integer_face.to_i
        offset = end_offset + 1
        return value, offset

    else
        raise "Unknown bdecode object marker #{source[offset].chr.inspect}"

    end
end

#### Deep freeze

class String
    def deep_freeze
        freeze
        return self
    end
end

class Array
    def deep_freeze
        each do |item|
            item.deep_freeze
        end
        freeze
        return self
    end
end

class Integer
    def deep_freeze
        return self
    end
end

class Hash
    def deep_freeze
        each_pair do |key, value|
            key.deep_freeze
            value.deep_freeze
        end
        freeze
        return self
    end
end

#### Encapsulated torrent object

class Torrent
    # the parsed torrent data structure; frozen
    attr_reader :data

    # the info dictionary
    attr_reader :info

    # the piece data; a string
    attr_reader :pieces
   
    # piece length; an integer
    attr_reader :piece_length

    # file data; nil or a list of dictionaries
    attr_reader :files

    # root object name; a string
    attr_reader :name

    # total length of data in this torrent; a non-negative integer
    attr_reader :length

    # number of pieces; a non-negative integer
    attr_reader :piece_count

    def initialize bencoded_data
        super()
        @data = bdecode bencoded_data
        @data.deep_freeze

        # validate and extract some data
        @info = @data['info']
        unless @info.is_a? Hash then
            raise Invalid::new(".info is not a dictionary")
        end

        @pieces = @info['pieces']
        unless @pieces.is_a? String then
            raise Invalid::new(".info.pieces is not a string")
        end

        @piece_length = @info['piece length']
        unless @piece_length.is_a? Integer then
            raise Invalid::new(".info.'piece length' is not an integer")
        end
        unless @piece_length > 0 then
            raise Invalid::new(".info.'piece length' is not a positive integer")
        end

        @files = @info['files']
        if @files then
            unless @files.is_a? Array then
                raise Invalid::new(".info.files exists but is not a list")
            end

            @length = 0
            @files.each_with_index do |file_item, i|
                unless file_item['path'].is_a? Array then
                    raise Invalid::new(".info.files[#{i}].path is not a list")
                end
                unless file_item['path'].all?{|c| valid_filename_component? c} then
                    raise Invalid::new(".info.files[#{i}].path is not a list of valid filename components")
                end

                validate_length file_item['length'], ".info.files[#{i}].length"
                @length += file_item['length']
            end
            unless @info['length'].nil? then
                raise Invalid::new(".info.files exists but .info.length exists, too")
            end
        else
            validate_length @info['length'], ".info.length"
            @length = @info['length']
        end

        @name = @info['name']
        unless @name.is_a? String then
            raise Invalid::new(".info.name is not a string")
        end
        unless valid_filename_component? @name then
            raise Invalid::new(".info.name is not a valid unqualified single-level filename")
        end

        @piece_count = (@length + @piece_length - 1) / @piece_length # integer division
        unless @pieces.length == @piece_count * 20 then
            raise Invalid::new("total data size (#@piece_count pieces of #@piece_length bytes each) does not match the length of .info.pieces (#{@pieces.length})")
        end

        return
    end

    def validate_length value, address
        unless value.is_a? Integer then
            raise Invalid::new("#{address} is not an integer")
        end
        unless value >= 0 then
            raise Invalid::new("#{address} is not a non-negative integer")
        end
        return
    end
    private :validate_length

    def valid_filename_component? s
        return s.is_a?(String) && !s.include?(?/) && !['.', '..'].include?(s)
    end
    private :valid_filename_component?

    def multifile?
        return !@files.nil?
    end

    class Invalid < Exception
        def initialize message
            super message
            return
        end
    end
end

#### File system traversal

# Iterate over all descendants of a given directory that are not directories.
def each_nondir_descendant dir, base_dir = '.', &thunk
    Dir::entries(File::join(base_dir, dir)).each do |entry|
        next if ['.', '..'].include? entry
        qentry = dir == '.' ? entry : File::join(dir, entry)
        if File::directory? File::join(base_dir, qentry) then
            each_nondir_descendant qentry, base_dir, &thunk
        else
            yield qentry
        end
    end
    return
end

# Cursor for traversing over the file list piecewise
class Multifile_Cursor
    attr_accessor :initial_skip

    # file_entries comes straight from a multifile torrent file
    def initialize file_entries
        super()
        @file_entries = file_entries
        @current_file_index = 0
        @initial_skip = 0
        return
    end

    # Has the cursor reached end of the file list?
    def eof?
        return @current_file_index >= @file_entries.length
    end

    # Advance the cursor by given piece_length.
    # Return [[filename, begin_offset ... end_offset, file_expected_size], ...].
    def step piece_length
        fragments = []
        bytes_left = piece_length
        while bytes_left > 0 and !eof? do
            current_file_entry = @file_entries[@current_file_index]
            filename = File::join(*current_file_entry['path'])
            filesize = current_file_entry['length']
            start_offset = @initial_skip
            if start_offset + bytes_left > filesize then
                end_offset = filesize
                bytes_left -= filesize - start_offset
                fragments.push [filename, start_offset ... end_offset, filesize]
                # advance to next file
                @current_file_index += 1
                @initial_skip = 0
            else
                end_offset = start_offset + bytes_left
                fragments.push [filename, start_offset ... end_offset, filesize]
                @initial_skip += bytes_left
                bytes_left = 0
            end
        end
        return fragments
    end
end

#### Parse command line

$quiet = false
$extract_valid_pieces = nil # if true, holds the directory name

$0 = 'chktor' # set our name for GetoptLong's error reporting

begin
    GetoptLong::new(
        ['--quiet', '-q', GetoptLong::NO_ARGUMENT],
        ['--extract-valid-pieces', '-x', GetoptLong::REQUIRED_ARGUMENT],
        ['--help', '-h', GetoptLong::NO_ARGUMENT],
        ['--version', '-V', GetoptLong::NO_ARGUMENT]
    ).each do |opt, arg|
        case opt
        when '--quiet' then
            $quiet = true
        when '--extract' then
            raise "chktor: #{arg}: not a directory" unless File::directory? arg
            $extract_valid_pieces = arg
        when '--help' then
            puts USAGE
            exit 0
        when '--version' then
            puts IDENTIFICATION
            exit 0
        end
    end
rescue GetoptLong::InvalidOption, GetoptLong::MissingArgument
    # the error has already been reported by GetoptLong#each
    exit 1
end

unless (1 .. 2).include? ARGV.length then
    $stderr.puts "chktor: argument count mismatch"
    exit 1
end

$torrent_filename = ARGV[0]
$checkee = ARGV[1]

#### The work begins here

torrent = nil # declare
begin
    torrent = Torrent::new IO::read($torrent_filename)
rescue Torrent::Invalid
    $stderr.puts "chktor: #$torrent_filename: #{$!.message}"
    exit 1
end

$checkee ||= torrent.name

errors_detected = false # so far, no errors or we would have exited already

if torrent.info['md5sum'] then
    $stderr.puts "chktor: warning: ignoring .info.md5sum"
end

unless torrent.multifile? then
    # single file
    # synthesise a file array of the single file
    file_array = [{'path' => [File::basename($checkee)], 'length' => torrent.length}]
    dirname = File::dirname $checkee
    file_array.deep_freeze
else
    # multiple files
    file_array = torrent.files
    dirname = $checkee
end

raise "Content directory #{dirname.inspect} missing" unless File::directory? dirname

cursor = Multifile_Cursor::new file_array
valid_pieces = 0
(0 ... torrent.piece_count).each do |piece_index|
    expected_piece_hash, = torrent.pieces[piece_index * 20 ... (piece_index + 1) * 20].unpack 'H*'
    piece_content = ''
    acquisition_failed = false
    fragments = cursor.step torrent.piece_length
    display_fragments = fragments.map do |filename, range, expected_file_size|
        [range.begin != 0 ? "... " : "", filename, range.end != expected_file_size ? " ..." : ""].join ''
    end
    print "##{piece_index}/#{torrent.piece_count} (#{display_fragments.join ', '}) " unless $quiet
    $stdout.flush
    fragments.each do |filename, range, expected_file_size|
        port = nil
        begin
            port = open(File::join(dirname, filename), 'rb')
        rescue Errno::ENOENT, Errno::EACCES
            $stderr.puts "chktor: #{File::join dirname, filename}: open failed: #{$!.message}"
            acquisition_failed = true
            errors_detected = true
            # we'll continue anyway so as to be able to determine the presence of following files in this fragment
            next
        end
        if port.stat.size != expected_file_size then
            $stderr.puts "chktor: #{File::join dirname, filename}: size mismatch: expected #{expected_file_size}, actual #{port.stat.size}"
            errors_detected = true
            # but we're not ceasing acquisition of this piece
        end
        port.seek range.begin
        subpiece = port.read(range.end - range.begin)
        unless subpiece.length == range.end - range.begin then
            $stderr.puts "chktor: #{File::join dirname, filename}: short read"
            acquisition_failed = true
            errors_detected = true
        end
        port.close
        piece_content << subpiece
    end
    unless acquisition_failed then
        actual_piece_hash = Digest::SHA1.hexdigest piece_content
        if actual_piece_hash == expected_piece_hash then
            valid_pieces += 1
            print " ok" unless $quiet
            if $extract_valid_pieces then
                open "#{File::join $extract_valid_pieces, piece_index.to_s}", 'wb' do |port|
                    port.write piece_content
                end
                print " saved" unless $quiet
            end
            puts unless $quiet
        else
            puts " HASH MISMATCH" unless $quiet
            errors_detected = true
        end
    else
        puts " ACQUISITION FAILED" unless $quiet
        errors_detected = true
    end
end

# Check for any extra files
if torrent.multifile? then
    torrent_entry_filename_list = Set::new(file_array.map{|e| File::join(*e['path'])})
    each_nondir_descendant '.', dirname do |filename|
        unless torrent_entry_filename_list.include? filename then
            puts "Extra file: #{filename}"
        end
    end
end

if errors_detected then
    # Note that it is possible for errors to be present even when all pieces
    # are valid if some of the files has trailing junk.
    puts "Error(s) detected, only #{valid_pieces} out of #{torrent.piece_count} pieces are valid."
    exit 1
else
    puts "Validation successful."
    exit 0
end
